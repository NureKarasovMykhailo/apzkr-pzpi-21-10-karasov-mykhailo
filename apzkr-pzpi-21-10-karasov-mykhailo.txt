Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для оптимального керування робочим персоналом підприємства


	    Студент гр. ПЗПІ-21-10		_________________ Карасьов М.А.
							(підпис)
	    Керівник роботи			_________________ доц. Лещинська І.О.
							(підпис)
							      Роботу захищено «__» ______ 2024.р
							      з оцінкою _______________________
	    Комісія:					_______________ доц. Лещинський В.О.
								(підпис)
							_______________ доц. Лещинська І.О.
								(підпис)
							_______________ ст. викл. Сокорчук І.П.
								(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук	 	 Кафедра програмної інженерії		
Спеціальність 121 – Інженерія програмного забезпечення					
Курс  	3	 Семестр						6				
Навчальна дисципліна Архітектура програмного забезпечення				

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

				Карасьову Михайлу Анатолійовичу					
1. Тема роботи: «Програмна система для оптимального керування робочим персоналом підприємства»										
2. Термін узгодження завдання курсової роботи «04»	 	березня	 2024 р.
3. Термін здачі студентом закінченої роботи «15»	червня	 2024 р.
4. Вихідні дані до проєкту (роботи): У програмній системі передбачити: додавання нового підприємства, робітників, формування оптимального робочого розкладу, відстежування стану робітників. Використовувати ОС Windows 10 або 11, СКБД PostgreSQL, середовище розробки WebStorm							
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, Vision and Scope документ, проектування програмного проєкту, структуру бази даних, кодування програмного проєкту, висновки, перелік посилань, додатки																
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма станів, UML – діаграма взаємодії, UML діаграма діяльності, UML діаграма пакетів, 											



КАРЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	05.03.2024	Виконано
2	Проектування програмного
проекту	20.03.2024	Виконано
3	Кодування програмного проекту	20.04.2024	Виконано
4	Оформлення пояснювальної записки	20.05.2024	Виконано
5	Захист курсової роботи	09.06.2024	Виконано


Дата видачі завдання «	  4   » 		березня	 2024 р.

		Керівник 					          	          доц. Лещинська І.О.
								(підпис)
		
Завдання прийняв до виконання
ст. гр. ПЗПІ-21-10					      Карасьов М.А.
					     (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 58 с., 11 рис., 3 табл., 6 додатків, 6 джерел.
АКТИВНОСТІ, КЕРУВАННЯ РОБІТНИКАМИ, ПІДПРИЄМСТВО, РОБІТНИКИ, РОБОЧА ЗМІНА, РОБОЧИЙ РОЗКЛАД, СТАН РОБІТНИКІВ.

Об’єктом дослідження даної роботи є оптимальне керування робочим персоналом підприємств. На сьогоднішній день це питання є дуже актуальним, так як це дозволяє ефективно використовувати людські ресурси підприємства та підвищувати його продуктивність, що є дуже важливим у сучасному світі.
Метою курсової роботи є розробка складної програмної системи, яка дозволить ефективно керувати робочим персоналом підприємства, система буде зберігати інформацію про робітників підприємства та про роботи, які необхідно виконувати на цьому підприємстві. Система, за допомогою спеціальних пристроїв, буде відстежувати фізичний стан робітників, та на основі цих даних підбирати працівникам оптимальні роботи.
Розробка базується на наступних технологіях: PostgreSQL у якості системи керування базами даних, Node JS та фреймворку Express для серверної/back-end частини, IoT пристрій, розроблений за допомогою Arduino, мікроконтролеру ESP32, датчику температури та пульсу, веб – клієнт, розроблений на мові програмування JavaScript та бібліотеці React та мобільного застосунку, розроблений з використанням мови Kotlin та розрахований на мобільну платформу Android.
У результаті виконання курсової роботи має бути розроблена складна програмна система, яка дозволить найбільш оптимально керувати робітниками підприємства. Система має складатися з наступних компонентів: серверна частина, IoT пристрій, веб – клієнт, мобільний застосунок. Компоненти мають утворювати єдину програмну систему та взаємодіяти один з одним.
ЗМІСТ


Вступ	7
1 Vision and Scope документ	8
1.1 Бізнес - вимоги	8
1.1.1 Передумови	8
1.1.2 Бізнес - можливості	8
1.1.3 Бізнес можливості	10
1.1.4 Потреби клієнтів та ринку	10
1.1.5 Бізнес - ризики	11
1.2 Концепція рішення	11
1.2.1 Окреслення концепції	11
1.2.2 Головна функціональність	12
1.2.3 Припущення та залежності	13
1.3 Рамки та обмеження	13
1.3.1 Рамки первинного випуску	13
1.3.2 Рамки наступних випусків	16
1.3.3 Обмеження та виключення	16
1.4 Бізнес – контекст	18
1.4.1 Профілі зацікавлених сторін	18
1.4.2 Пріоритети проєкту	19
1.4.3 Робоче середовище	20
2 Проектування програмного проєкту	22
2.1 Загальне проектування системи	22
2.2 Проектування серверної частини	23
2.3 Проектування IoT пристрою	26
2.4 Проектування веб – застосунку	27
3 Структура бази даних	33
4 Кодування програмного проєкту	35
4.1 Загальне кодування системи	35
4.2 Кодування серверної частини	35
4.3 Кодування IoT пристрою	37
4.4 Кодування веб-застосунку	37
4.5 Кодування мобільного застосунку	39
Висновки	41
Перелік джерел посилань	42
Додаток А REST Специфікація	43
Додаток Б Оформлення підписки за допомогою API	48
Додаток В Знаходження найкращого робітника для виконання активності	50
Додаток Г Програмний код IoT пристрою	54
Додаток Д Маршрутизація веб-клієнту	57
Додаток Ж Перевірка на плагіат	58



 
ВСТУП


На сьогодення існує величезна кількість галузей та професій, де невідповідний фізичний, або моральний стан робітників може поставити під загрозу безпеку, та навіть, життя інших людей. Серед таких професій, наприклад, лікарі, машиністи, робітники на критичних підприємствах, рятувальники тощо. Для того, щоб максимально зменшити кількість можливих нещасних випадків, є дуже корисним спостерігати за фізичним та/або моральним станом робітників.
Крім того, спостереження за станом робітників, його аналіз, та виконання певних дій на основі інформації про нього, може суттєво підвищити продуктивність різних підприємства, що є дуже актуальною проблемою на сьогодення.
Метою даної курсової роботи є розробка «Програмної системи з оптимального керування робочим персоналом підприємства». Вона дозволить спостерігати за станом робітників підприємства, роботами на підприємстві, для виконання яких необхідні робітники. Також вона дозволить автоматизовано обирати для робітників роботи, на основі фізичного стану робітників та інформації про саму роботу.
Розробка даної програмної системи потребує створення наступних компонентів: серверна частина, веб – застосунок, IoT або SmartDevice пристрій, мобільний застосунок.
Під час виконання курсової роботи були використанні наступні технології: СУБД PostgreSQL, мови програмування TypeScript, JavaScript, Kotlin, платформа NodeJS, фреймворк Express, бібліотека React, для створення IoT пристрою використовується Arduino.
Результатом виконання курсової роботи є розроблена складна програмна система, яка складається з back-end частина, front-end частини, IoT або SmartDevice та мобільного застосунку.


1 VISION AND SCOPE ДОКУМЕНТ
1.1 Бізнес - вимоги


1.1.1 Передумови


У сучасному світі існує безліч професій та галузей, де стан здоров’я і психічний стан працівників мають вирішальні значення. Такі професії, де від робітника можуть залежати життя та безпека інших людей, ставлять особливі вимоги до фізичного та психічного самопочуття робітників. Наприклад, водії, машиністи, лікарі, працівники на критичних підприємствах – мають велику відповідальність, під час виконання своїх професійних обов’язків.
Запобігання можливим негативним наслідкам, які можуть виникнути внаслідок неадекватного фізичного стану працівника (втома, проблеми зі здоров’ям тощо), є надзвичайно важливим завданням. Забезпечення безпеки та ефективності у роботі вимагає уважного контролю за станом працівників перед початком робочого дня, щоб уникнути непередбачених ситуацій та навіть зберегти життя та здоров’я людей.


1.1.2 Бізнес - можливості


Важливим етапом перед створенням нової програмної системи, є детальний аналіз ринку. Тому спочатку розглянемо деякі існуючі системи – аналоги.
По – перше, розглянемо програмну систему Limenade[1], яка дозволяє відслідковувати фізичну активність робітників, кількість спалених калорій та надає допомогу щодо усунення стресу.  Проте ця система не забезпечує суворий контроль за станом робітників і не здійснює відповідні заходи у разі порушення їхнього стану.
По – друге, розглянемо сервіс Virgin Pulse[2]. Він дозволяє робітникам проводити аналіз свого фізичного та психічного стану, а також має зручний веб – інтерфейс. Однак цей сервіс не підходить для підприємств з більш суровими вимогами,  де необхідне більш сурове відстежування стану робітників.
Іншим прикладом аналога розроблюваної системи є застосунок MoodPande[3] дозволяє відслідковувати фізичний стан робітника. Однак розроблювана система, на відмінну від MoodPande, буде поєднувати відстежування як фізичного стану робітників так і час, який вони провели за активною працею.
Ще одним, на цей раз апаратним, прикладом аналога розроблюваної системи, є так звані, розумні годинники. На сьогодення існує велика кількість різних розумних годинників, які дають можливість відслідковувати стан людини. Розроблювана система наддасть зручний механізм відстежування стану робітників через подібні пристрої, а також можливість попередження про незадовільний фізичний стан робітника, що може суттєво зменшити ймовірність нещасних випадків на різних підприємствах.
Для даного проєкту, були обрані наступні моделі монетизації: надання платного доступу до функцій та продаж реклами на платформі. Користувачі матимуть можливість отримати повний доступ до усього функціоналу програмної системи за певну плату. Також гроші можуть бути отриманні за рахунок продажу реклами на платформі.
Дана програмна система орієнтована на європейський та американський ринки корпоративних програмних систем. Цей ринок є досить перспективним для даної програмної системи, завдяки розвитку технологій, які дозволяють автоматизувати збір та аналіз фізичного стану робітників.






1.1.3 Бізнес можливості


Проєкт має наступні бізнес цілі:
– Зменшення протягом року кількості нещасних випадків на різних підприємствах України на 10%;
– Зменшення ресурсів, необхідних для контролю за станом робітників, перед початком їх діяльності;
– Зменшення матеріальних витрат, спричинених не відповідним станом робітників;
– Підвищення рівня продуктивності підприємств, за рахунок забезпечення відповідного стану робітників;
Проєкт має наступні критерії, за якими буде визначатися успіх проєкту:
– Замовлення даної системи 1 000 підприємствами протягом 12 місяців;
– Прибуток у вигляді 50 000$ на рік;
– 10 000 зареєстрованих на платформі користувачів, за рік;


1.1.4 Потреби клієнтів та ринку


Можна виділити наступні потреби ринку, на який орієнтується розроблюваний продукт:
– Надійна перевірка фізичного стану робітника, перед початком виконання ним професійних обов’язків;
– Автоматизація процесу формування робочого розкладу;
– Створення єдиної системи для керування робочим персоналом підприємства;
– Відслідковування стану робітників підприємства;

1.1.5 Бізнес - ризики


При виставлені даної системи на ринок корпоративних програмних систем, можна зустрітися з наступними бізнес ризиками:
– Необхідність просування продукту. Продукт, який розробляється, є новою системою, яку необхідно буде рекламувати для продажів підприємствам. Цей ризик має бути усунутий пошуком спонсорів серед різних підприємців та установ з охорони праці;
– Конкуренція на ринку. На ринку корпоративних програмних систем існує конкуренція та через це існує ризик малих продажів програмної системи. Цей ризик має бути усунутий за допомогою великої функціональності системи та її можливостями щодо автоматизації, що виділить її на фоні конкурентів;
– Не бажання підприємств змінювати програмне забезпечення. Деякі підприємства можуть не захотіти змінювати, програмне забезпечення, яке вони вже використовують, на наш продукт. Цей ризик можна усунути за рахунок великій функціональності та можливостями автоматизації, що несе даний продукт.


1.2 Концепція рішення


1.2.1 Окреслення концепції


Програмна система має за мету автоматизування та оптимізування процесів управління робочим персоналом підприємства. Система буде надавати детальний облік фізичного стану робітників та робити висновки щодо їхньої готовності до виконання своїх робіт на підприємстві. Крім того, буде надана можливість формування оптимального робочого розкладу для робітників підприємства.
Впровадження даної системи зменшить вірогідність нещасних випадків, причина яких був міг би бути не відповідний фізичний стан робітників, та збільшить продуктивність підприємств за рахунок оптимізації та автоматизації процесів управління робочим персоналом.


1.2.2 Головна функціональність


Для повноцінної роботи програмної системи, користувач має бути забезпечений наступним функціоналом:
– Реєстрація та авторизація користувача;
– Керування складом робочого персоналу підприємства;
– Відслідковування за допомогою відповідних датчиків фізичного стану робітників підприємства (температура тіла, пульс, кількість часу активної роботи);
– Реєстрація підприємства у системі;
– Оформлення підписки на сервіс, для отримання повного функціоналу програмної системи;
– Формування оптимального розподілу робочого персоналу, в залежності від стану та навичок робітників, та складності виконання праці;





1.2.3 Припущення та залежності


Програмна система має наступні припущення:
– Усі пристрої, з яких складається система об’єднанні в мережі Інтернет;
– Підприємство має достатню кількість IoT пристроїв для відстежування стану робітників;
– На телефонах робітників підприємств встановлений застосунок;
Також програмна система має наступні залежності:
– Залежність від постачання IoT пристроїв. Для системи необхідна велика кількість IoT пристроїв, яка має бути забезпечена;
– Залежність від співпраці з підприємствами, які забезпечують просування продукту;
– Залежність від законодавства певних країн у політики, щодо охорони праці;


1.3 Рамки та обмеження


1.3.1 Рамки первинного випуску


Система має наступні функції, які будуть реалізовані у першому релізі програмної системи та, які необхідні для запуску проєкту:
Серверна/back-end частина:
– Створення аккаунту. Будь-який користувач, повинен мати можливість створити свій аккаунт у системі;
– Авторизація. Зареєстрований користувач має можливість авторизуватися у системі, завдяки введенню свого пароля та електронної пошти;
– Оформлення підписки на сервіс. Зареєстрований користувач повинен мати можливість оформити підписку на сервіс. Підписка наддасть йому можливість зареєструвати своє підприємство у застосунку;
– Можливість зареєструвати своє підприємства у системі. Користувач, який оформив підписку на сервіс має можливість зареєструвати своє підприємство у застосунку;
– Додавання робітників до свого підприємства. Адміністратори підприємства мають можливість додавати аккаунти робітників, до свого підприємства;
– Додавання діяльності на підприємстві. Адміністратор підприємства має можливість додати певну діяльність підприємства, для виконання якої необхідні робітники;
– Обробка даних про фізичний стан робітників. До серверної частини будуть надходити дані про фізичні параметри певного робітника. Система буде робити висновки про загальний стан робітника;
– Оптимальний розподіл робітників по роботах. В залежності від виду роботи, необхідної кількості робітників, стану кожного робітника, система буде формувати оптимальний розподіл робітників по роботах, для забезпечення продуктивності підприємства;
– Редагування профіля користувача. Будь-який, зареєстрований користувач має можливість змінювати дані свого профіля, у будь-який момент;
– Експорт\імпорт даних з бази даних. Адміністратор системи мають можливість здійснювати експорт\імпорт даних з БД. Дані з БД мають бути зашифровані;
– Надання механізму безпеки даних. Шифрування важливих даних та шифрування резервних копій даних;
– Адміністрування системи. Користувачі з роллю адміністратор системи мають можливість виконувати налаштування та адміністрування системи;
Клієнтська/front-end частина:
– Надання зручного інтерфейсу користувача для ефективної та легкої роботи з даними;
– Перегляд даних;
– Фільтрація даних;
– Сортування даних;
– Надання локалізації. Інтерфейс програмної системи підтримує англійську міжнародну та українську мови. Користувач може перемикати мову інтерфейсу у будь – який момент;
IoT пристрої:
– Збирання даних щодо пульсу та температури та часу, який працівник відпрацював;
– Відслідковування активності. В залежності від діяльності робітника IoT пристрої будуть надсилати інформацію щодо фізичної активності робітника
Mobile застосунок:
– Авторизація користувача. Користувач авторизується у системі за допомогою своєї адреси електронної пошти, та свого пароля;
– Перегляд стану робітника. Будь-який робітник може пройти обстеження, щодо свого фізичного стану, та отримати результат щодо нього;
– Перегляд робочого персоналу підприємства. Адміністратор підприємства має можливість перегляду усіх робітників, їх станів та за якими діяльностями, вони закріплені;
– Керування підприємство. З мобільного пристрою, адміністратор підприємства має можливість змінювати та/або видаляти інформацію про це підприємство;





1.3.2 Рамки наступних випусків


Виділено наступні функції, які не плануються у першому релізі системи, але плануються у наступних:
– Аутентифікація користувачів. Після створення нового аккаунта користувач має підтвердити свою особистість. Для цього він має відправити фотографію із своїм паспортом у руках. При успішній аутентифікація профіль користувача позначається, як аутентифікований.
– Доповнення функціоналу мобільного пристрою, усім функціоналом, що має веб – рішення.
– Корпоративний чат. Можливість робітників підприємства спілкуватися у своїх приватних чатах.
– Додавання на місце роботи робітників спеціальних датчиків, які будуть аналізувати кліматичні умови у приміщенні, ця інформація буде враховуватися при розподілі робітників по відповідним роботах.
– Можливість виставлення вакансій. Відповідний адміністратор підприємства зможе опубліковувати вакансії о необхідності певних працівників на підприємстві.


1.3.3 Обмеження та виключення


Програмна система має наступні обмеження:
– Обмеження пов’язане з законодавством. Закони та нормативи різних країн можуть регулювати обробку даних робітників та вимагати дотримання до конфіденційності;
– Обмеження щодо інтеграції з існуючими системами. Підприємство вже може використовувати певні програмні корпоративні системи, у цьому випадку виникає необхідність інтеграції системи;
– Обмеження щодо кількості розумних девайсів. Для повноцінної роботи програмної системи, підприємство має бути забезпечене у достатній кількості розумними девайсами;
– Обмеження щодо оновлень та підтримки. Після впровадження системи необхідними буде її підтримка та оновлення, що може вимагати ресурсів та часу.
– Технічні обмеження. Наявність застарілого апаратного та/або програмного забезпечення може ускладнити роботу програмної системи;
Система має наступні винятки, пов’язані з своєю роботою:
– Збої у роботі мережі Інтернет. Усі компоненти даної складної системи пов’язані з мережею Інтернет, тому проблеми з мережею можуть призвести до проблем з сумісності компонентів системи;
– Оновлення та сумісність. Оновлення компонентів системи, чи програмного та/або апаратного забезпечення може призвести до проблем з сумісності компонентів системи;
– Кібератаки. Система може бути вразлива до кібератак та втратити даних, про підприємство та його персонал;
– Виникнення проблем у роботі IoT пристроїв. Несправність у IoT пристроях може призвести до неадекватної поведінки системи;








1.4 Бізнес – контекст


1.4.1 Профілі зацікавлених сторін


Для кращого розуміння груп людей, які зацікавлені у розробці даного програмного продукту, заповнимо таблицю зацікавлених сторін (див. таблицю 1.1), де приведемо зацікавлені сторони, основні цінності для них, їх ставлення до прєкту, основні інтереси та обмеження.

Таблиця 1.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Підприємці та роботодавці	Автоматизація реєстрації та обліку 	Сподіваються, що програмна система 	Покращення методів керування 	Обмеження з можливою наявністю 
Підприємці та роботодавці	робочого персоналу, керування замінами та розподілу робочої сили	забезпечить ефективне керування робочою силою підприємства	персоналом. Підвищення ефективності трудових процесів	застарілого програмного чи апаратного забезпечення на підприємстві
Робітники підприємств	Забезпечення безпеки та комфорту на робочому місті	Очікують систему, яка буде адекватно оцінювати їх здатність до виконання певної роботи	Оцінка можливості виконувати певну роботу, попередження про ризики	Наявність фінансових ресурсів може бути обмежена
Продовження таблиці 1.1
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Регулюючі органи та організації з охорони праці	Дотримання законодавства у сфері охорони праці	Сприймають систему, як можливий інструмент для покращення умов праці	Зменшення кількості нещасних випадків на підприємствах	Необхідність дотримання законів та правових актів у сфері охорони праці 


1.4.2 Пріоритети проєкту


Для визначення плану робіт, пріоритетів, якості програмного продукту та фунціоналу, який необхідно реалізувати заповнимо таблицю пріорітетів проєкту (див. таблицю 1.2).

Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання 
(етапи)	Обмеження
(граничні значення)	Ступінь свободи
(допустимий діапазон)
План робіт	Первинний реліз системи має бути доступний 30.05.2024		



Продовження таблиці 1.2
Якість			У випуску первинного релізу мають бути реалізовані усі функції з пункту 3.1. Вони мають бути повністю робочі та протестовані
Персонал		Персонал складається з одного розробника	
Ціна			Бюджет проекту відсутній
Функціональність			Усі функції з пункту 3.1 даного документу мають бути включені до
			до первинного релізу програмної системи


1.4.3 Робоче середовище


Програмна система має наступне робоче середовище:
– Серверна\back-end частина буде розроблена на програмній платформі Node.js, фреймворку Express.js та мови TypeScript;
– Клієнтська\front-end частина буде розроблена за допомогою бібліотеці React та HTML5, CSS, JavaScript;
– Mobile застосунок буде розроблений за допомогою мови програмування Kotlin та з використанням бібліотеки Retrofit, для взаємодії з серверною частиною;
– IoT або SmartDevice пристрій буде розроблений за допомогою мови Arduino Sketch;
– У якості бази даних обрано реляційну базу даних PostgreSQL;
– Доступ до системи здійснюється через веб – застосунок (веб - доступ), мобільний застосунок (мобільний доступ) та через розумні пристрої;
– Система має  працювати при підключенні до мережі Інтернет, кількість відмов у роботі системи має бути зведена до нуля;
– Усі компоненти мають утворювати цілісну програмну систему, один компонент системи не повинен змушувати інші компоненти некоректно працювати;

 
2 ПРОЕКУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
2.1 Загальне проектування системи


Так як дана програмна система є складною (складається з декількох компонентів), опишімо загальний дизайн системи, та способи взаємодії компонентів між собою.
По – перше, для ілюстрація наявних компонентів у системі та способів їх взаємодії побудуємо діаграму розгортання (Deployment Diagram) (див. рис. 2.1).

Рисунок 2.1 – Діаграма розгортання

У якості сервера бази даних обрано PostgreSQL. Обмін даними між сервером та БД проходить за допомогою відповідного драйверу.
Система взаємодіє з базою даних, за допомогою серверної частини. Крім цього серверна частина взаємодіє з веб – застосунком, мобільною прикладною програмою та IoT пристроями за протоколом HTTP.
Сам користувач взаємодіє з системою за допомогою свого персонального комп’ютеру чи мобільного пристрою, які у свою чергу взаємодіють з клієнтською частиною по протоколу HTTP.
Отже, було виконане загальне проектування системи, далі перейдемо до проектування окремих компонентів системи.


2.2 Проектування серверної частини


Спочатку, для моделювання взаємодії серверної частини з зовнішніми користувачами (акторами) створімо UML діаграму прецедентів (див. рисунок 2.2).

Рисунок 2.2 – UML діаграма прецедентів для серверної частини
У системі наявні три види звичайних акторів: незареєстрований користувач, зареєстрований користувач та робітник підприємства. 
Незареєстрований користувач має лише можливість зареєструватися чи авторизуватися у системі.
Зареєстрований користувач може приєднатися до підприємства та оформити підписку на сервіс.
Також у системі наявні три типи акторів – адміністраторів: власник підприємства (користувач, який створив відповідне підприємство), адміністратор компанії та системний адміністратор. Власник підприємства може керувати усіма сутностями, які знаходяться у даному підприємстві, та формувати оптимальний робочий розклад робітників. Адміністратор підприємства має усі ж можливості власника підприємства, окрім зміни даних про саму сутність відповідного підприємства.
Системний адміністратор це окрема роль, користувачі з даним статусом мають можливість керувати усіма сутностями у системи, а також формувати резервні копії даних.
Для моделювання поведінки системи в залежності від її станів та подій, які впливають на ці стани побудуємо UML діаграму станів (див. рис. 2.3).

Рисунок 2.3 – UML діаграма станів для серверної частини

На діаграмі проілюстрована бізнес – логіка, з пошуку робітника, який найбільш підходить для виконання даної активності. По – перше обирається робітник, відбувається перевірка того чи має робітник необхідну освіту, якщо ні, то система обирає наступного робітника. Далі система перевіряє, чи відповідає фізичний стан даного робітника активності, якщо так, то робітник записується на дану активність, у іншому випадку – вибирається новий користувач.



2.3 Проектування IoT пристрою


Для ілюстрації взаємодії IoT пристрою з зовнішніми користувачами створімо UML діаграму прецедентів (див. рис. 2.4).

Рисунок 2.4 – UML діаграма прецедентів для IoT пристрою

Робітник має можливість вмикнути та вимкнути свій розумний пристрій. Крім того, він має можливість розпочати збір даних (розпочати відлік часу, який даний робітник працював), зібрати усі дані про свій стан (температура тіла, пульс, час роботи) та переглянути їх. Також ці дані будуть відправлені на серверну частину програмної системи, для подальшої обробки.
Далі створімо діаграму взаємодії (див. рис. 2.5), це надасть можливість наочно показати, як об’єкти системи взаємодіють між собою в певному сценарії або випадку використання. Вона ілюструє послідовність викликів методів та обмін повідомленнями між об’єктами, що допомагає зрозуміти динамічні аспекти системи. 

Рисунок 2.5 – Діаграма взаємодії для IoT пристрою

Пристрій працює наступним чином: IoT пристрій отримує від робітника дані (пульс, температура, час роботи). Після чого дані виводяться користувачу, та відправляються на серверну частину, для обробки. На серверній частині відправлені дані зберігають у базу даних.


2.4 Проектування веб – застосунку


Опишемо шлях взаємодії клієнтського веб – застосунку з зовнішніми користувачами (акторами), для цього створімо UML діаграму прецедентів (див. рис. 2.6).
На діаграмі визначені наступні актори: не авторизований користувач (має можливість зареєструвати новий акаунт, чи увійти в існуючий аккаунт), звичайний користувач, робітник компанії, адміністратор компанії та системний адміністратор.
Звичайний користувач має можливість редагувати інформацію свого профіля, оформити підписку на сервіс та створити власну компанію та керувати нею.
Робітник компанії може переглядати інформацію, яка відноситься до даної компанії.

Рисунок 2.6 – UML діаграма прецедентів для веб – застосунку

Адміністратор компанії керує бізнес – сутностями у рамках однієї компанії, до якої він належить.
Адміністратор системи керує усіма бізнес – сутностями системи та бізнес – процесами системи.
Далі для визначення архітектури системи та організації системи на високому рівні, напишімо діаграму пакетів (див. рисунок 2.7).
На діаграмі було виділено наступні пакети (програмні модулі):
̶	App – кореневий пакет застосунку;
̶	Pages – пакет, який містить повні сторінки, які будуть показуватися користувачу;
̶	Components – пакет з різними UI компонентами, з яких складаються сторінки;
Рисунок 2.7 – UML діаграма пакетів для веб – застосунку

̶	API – пакет з класами, об’єктами та методами для взаємодії з серверною частиною;
̶	Locales – пакет з файлами локалізації;
̶	Store – пакет з класами, об’єктами та методами для забезпечування відстеження станів об’єктів;
̶	Utills – пакет з допоміжними функціями;
̶	Styles – пакет з CSS стилями;


2.5 Проектування мобільного застосунку


Промоделюємо взаємодію мобільного застосунку з зовнішніми акторами за допомогою UML діаграми прецедентів (див. рис. 2.8).

Рисунок 2.8 – UML діаграма прецедентів для мобільного застосунку

Були визначені наступні актори: не авторизований користувач, авторизований користувач та адміністратор компанії.
Не авторизований користувач не має доступу до фунціоналу системи, доки не пройде процес авторизації, чи реєстрації.
Авторизований користувач має можливість перегляду та аналізу інформації, яка відноситься до компанії, у якій він зареєстрований.
Адміністратор компанії має можливість керувати сутностями робітників та робіт, у рамках компанії, до якої він відноситься. Також він має можливість записувати робітника, на найбільш оптимальну активність, за допомогою бізнес – логіки, яка знаходиться на серверній частині.
Далі, для визначення архітектури мобільного застосунку, створімо UML діаграму пакетів (див. рис. 2.9).

Рисунок 2.9 – UML діаграма пакетів для мобільного застосунку

У системі було виділено наступні програмні пакети:
̶	App – кореневий пакет, відповідає за запуск застосунку;
̶	Models – пакет, який містить моделі відповідно до MVC архітектури;
̶	Controllers – пакет, який містить контролери відповідно до MVC архітектури;
̶	Views – пакет, що містить представлення відповідно до MVC архітектури;
̶	Network – пакет, який містить класи та методи для взаємодії мобільного застосунку з серверної частиною;
̶	Adapters – пакет, який містить адаптери, вони надають можливість виводу списку даних;
̶	Utills – пакет з допоміжними методами та класами;
̶	Res – пакет з Android ресурсами; 
 
3 СТРУКТУРА БАЗИ ДАНИХ


Для зберігання даних, необхідно розробити відповідну базу даних. Для даного проєкту була обрана реляційна база даних PostgreSQL. Даний тип баз даних було обрано через те, що він сприяє цілісності даних та забезпечує транзакційну безпеку. Сама СУБД PostgreSQL обрана через те, що вона є масштабованою, продуктивною, має велику спільноту та підтримує високу кількість вбудованих функцій.
Для моделювання та візуалізації структури БД з точки зору бізнес – сутностей та взаємозв’язків між ними, створімо ER – модель даних (див. рисунок 3.1).

Рисунок 3.1 – ER – модель даних

ER – діаграма містить наступні сутності:
̶	Користувачі. Містить інформацію про користувачів застосунку;
̶	Ролі. Ролі, які можуть мати користувачі, окремий користувач може мати декілька ролей;
̶	Освіти. Освіти, які можуть мати користувачі. Користувач може мати декілька освіт;
̶	Підписки. Зберігають інформацію про підписку певного користувача.;
̶	Складність. Представляють дані про складність певної діяльності на підприємстві;
̶	Підприємство. Містить інформацію про певне підприємство;
̶	Сканер. Представляє IoT пристрій  який можна закріпити за користувачем;
̶	Діяльності. Містить інформацію про певну діяльність, виконання якої вимагає певну освіту, та за яку можна закріпити користувачів;
̶	Історія сканування. Містить інформацію, яку надсилають IoT пристрої, відносяться до певного сканеру та користувача;
 
4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1 Загальне кодування системи


Увесь джерельний код усіх компонентів системи був завантажений до відповідного GitHub репозиторію[4]. Також був створений відеоролик з функціонального тестування компонентів системи, який був опублікований на платформі YouTube[5].


4.2 Кодування серверної частини


Серверна / back-end частина написана за допомогою програмної платформи Node JS, фреймворку Express JS та мови програмування TypeScript.
Серверна частина відповідає за усю бізнес – логіку програмної системи. Серверна частина побудована за принципами чистої архітектури. Головна ідея даної архітектури полягає у розподілу системи на окремі рівні абстракції. Це дозволяє забезпечити високий рівень масштабованості, зручності тестування та підтримки, та зменшує залежність між компонентами системи. Застосунок поділений на декілька шарів: шар домену (шар, який містить основну бізнес – логіку застосунку та моделі даних), шар застосунку (містить бізнес – логіку та функції обробки даних), шар представлення (шар, який містить інтерфейс користувача або API інтерфейс, через який користувач взаємодіє з сервером), шар інфраструктури (шар у якому розташовані залежності від бази даних, зовнішніх API, фреймворків та бібліотек).
Сам сервер взаємодіє у усіма іншими клієнтськими компонентами програмної системи за допомогою REST API (див. додаток А). Взаємодія з базою даних відбувається за допомогою ORM Sequelize.
Розглянемо бізнес – логіку пов’язану з авторизацією у системі. Авторизація у системі здійснюється за допомогою «Json Web Token», або JWT токену. Токен генерується при успішній авторизації чи реєстрації користувача, та містить дані користувача, до яких є необхідність часто звертатися. Час існування токену дорівнює 24 години, після закінчення цього часу користувачу прийдеться знову авторизуватися у системі.
Інша частина бізнес – логіки, яку я б хотів описати, це оформлення підписки на сервіс (див. додаток Б). Оформлення підписки здійснюється за допомогою PayPal API. Якщо користувач, успішно оформив підписку, то для даного користувача у БД створюється сутність підписки, яка містить усі дані про неї. Користувач, який оформив підписку може додати власне підприємство (тільки одне) до системи.
Далі опишемо бізнес – логіку з формування оптимального робочого розкладу (див. додаток В). Для пошуку для даної активності кращого робітника використовується метод математичної згортки. Обирається користувач, який має необхідну освіту, потім отримується інформація від IoT пристрою, про стан даного робітника (температура, пульс, час, який користувач працював). Ці дані, та складність виконання активності переводяться у чисельний коефіцієнт, який тим більший чим більше даний коефіцієнт відхиляється від норми. На основі цих даних формується згортка та обирається користувач, який має найбільше значення згортки.
Також були вживанні заходи з забезпечення безпеки даних користувача, а саме хешування паролів у базі даних, для того щоб виключити можливість отримання доступу до акаунтів користувачів зловмисниками.







4.3 Кодування IoT пристрою


IoT пристрій розроблений за допомогою платформи Arduino та эмулятору Wokwi.. Сам пристрій складається з мікроконтролеру ESP32, датчика температури DHT22, датчику пульсу та звичайної кнопки.
IoT пристрій взаємодіє з серверною частиною за REST API та по протоколу HTTP.
Програмний код IoT пристрою наведений у додатку Г.
У програмному коді спочатку визначаються змінні, для підключення до мережі Інтернет, шляху для відправки даних на сервер, та визначаються піни для датчиків та кнопки.
У функції setup() відбувається ініціалізації датчиків, підключення до мережі Інтернет та вивід відповідних повідомлень.
У функції loop від робітника очікується натискання на кнопку. При першому натисканні на кнопку зберігається час, коли він на неї натиснув. При другому натисканні вираховується різниця між другим та першим натисканням на кнопку, отримуються дані з датчика температури та датчику пульсу.
Після цього за допомогою бібліотеки HTTPClient, дані по визначеному маршруту та методу POST відправляються на серверну частину.


4.4 Кодування веб-застосунку


У якості програмних засобів для розробки веб – клієнту були обрані: мова програмування JavaScript, бібліотека React, взаємодія веб – клієнту з серверною частиною відбувається за допомогою бібліотеки Axios. Даний вибір був обумовлений тим, що дані програмні засоби є дуже популярними, мають велику спільноту, велику кількість бібліотек для вирішення великої кількості проблем, та не є складними.
Веб – частина взаємодіє лише з серверної частини програмної системи. Взаємодія відбувається, як було раніше сказано, за допомогою бібліотеки Axios та протоколу HTTP.
Як архітектурне рішення було обрана архітектура, основана на вертикальній «слайсовій» архітектурі. Її ідея полягає у розподілені коду на вертикальні шари, кожен з яких містить окрему бізнес - сутність. Кожен шар містить усі необхідні йому файли та/або модулі для реалізації певної логіки або функціональності. Основною перевагою цього підходу є модульність. Окремі частини коду легко виділяються в окремі модулі, без впливу на іншу частину застосунку. Також вона забезпечує високий рівень можливості до тестування та підтримки. Однак присутні проблеми з можливими випадками дублювання коду та проблемами з ізоляцією шарів.
Опишемо логіку авторизації у системі, яка є дуже важливою, бо користувач отримує доступ до майже усього функціоналу системи, лише після авторизації. Авторизація відбувається за допомогою JWT токену, який отримується з серверної частини, у разі успішної авторизації користувачем. У токені зашифрована найважливіша інформація про користувача, до якої є необхідність часто звертатися. Сам токен зберігається у LocalStorage, від туди ж він і береться у разі необхідності зробити запит на сервер, який вимагає заголовок авторизації. Час «життя» токену – 24 години.
Інша частини логіки, яка є важливою для веб – застосунку, це маршрутизація. Маршрутизація відбувається за допомогою бібліотеки react-router-dom. У програмному коді визначається три масиви з маршрутами, для різних ролей користувачів (не авторизований користувач, авторизований користувач, адміністратор системи) (див. додаток Д). Користувач без відповідної ролі не зможе перейти по маршруту, який відноситься до масиву маршрутів, іншої ролі.
Щодо будови веб – компоненті, базова сторінка складається з трьох складових: «шапки», основної частини та «підвалу». Крім того, під час роботи застосунку, за допомогою модулю MobX відбувається керування станом, авторизованого користувача. Це забезпечує швидкий доступ до інформації про авторизованого користувача, що сприяє підвищенню продуктивності застосунку.


4.5 Кодування мобільного застосунку


Застосунок буде розроблений для мобільної платформи Android. Дана платформа є найбільш популярною ОС для мобільних пристроїв.
Мобільний клієнтський застосунок є частиною складної програмної системи та взаємодіє з нею. А саме він буде взаємодіями з серверною частиною системи, за протоколом HTTP.
Для розробки мобільного клієнтського застосунку були обрані наступні технології: мова Kotlin, IDE Android Studio, для реалізації взаємодії з серверною частиною буде використовуватися бібліотека Retrofit. Даний вибір технологій є сучасним вибором для створення мобільних застосунків для платформи Android. Використання мови Kotlin для розробки Android застосунків, рекомендується компанією Google.
У проекті використовується MVC архітектура. Її ідея полягає у розділені застосунку на три основні шари:
Model – представляють дані та змініють свій стан на відповідь дій контролеру;
Controller – інтерпретують дії користувача, змініють відповідним чином моделі;
View – представляють дані користувача, реагують на зміни моделей;
Даний тип архітектури дозволяє розподілити відповідальність (що є одним з принципом SOLID[6][7]), є легким у підтримувані, масштабованим.
Опишемо логіку знаходження найбільш оптимальної активності, для певного робітника. По – перше користувач обирає робітника, для якого він хоче знайти оптимальну активність. Далі при наявності у користувача ролі адміністратора компанії, у нього з’являється можливість знайти для користувача найбільш оптимальну активність та записати користувача на неї. Знаходження оптимальної активності відбувається за допомогою бізнес – логіки, розташованої на серверній частині програмної системи. Для знаходження активності використовується метод математичної згортки.
 
ВИСНОВКИ


У ході виконання курсової роботи була розроблена складна програмна система, що дозволяє оптимально керувати робочим складом підприємства. Сама система складається з: серверної частини, веб – застосунку, IoT пристрою, мобільного застосунку. Усі ці компоненти утворюють єдину систему та взаємодіють один з одним.
Для з’ясовування потреб ринку та зацікавлених сторін та визначення функціоналу, який мав бути розроблений був написаний Vision and Scope документ, у пунктах якого були дані відповіді на дані запитання. Далі було виконане проектування системи. Для цього були розроблені різні UML діаграми (діаграми прецедентів, діаграми пакетів, діаграми станів, взаємодії та активності), для з’ясування будови, функціоналу та логіки кожної з частин програмної системи. Після чого відбулося визначення архітектурних підходів для кожного з компонентів системи, для того щоб зробити їх масштабованими, маючими можливості для здійснення рефакторингу програмного коду та тестування. Далі відбулося кодування системних компонентів, за допомогою відповідних обраних технологій (мови програмування, фреймворки, бібліотеки, тощо). У результаті виконання усіх цих кроків була отримана складна програмна система з керування робочого персоналу підприємства.
Сама система може бути застосована на підприємства, з метою покращення їх продуктивності та зменшення кількості нещасних випадків на них. Система надає можливість відстежувати стан робітників, за допомогою IoT пристроїв, здійснювати їх облік та формувати оптимальний робочий розклад, що може суттєво підвищити продуктивність підприємств. Також система має локалізацію, можливості щодо адміністрування, та вжиті заходи щодо безпеки даних.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАНЬ


1. Employee well-being programs customized for the way you work. Limeade. URL: https://www.limeade.com/ (дата звернення: 26.03.2024).
2. Virgin pulse | changing lives for good | virgin. Virgin.com. URL: https://www.virgin.com/virgin-companies/virgin-pulse (дата звернення: 25.03.2024).
3. Moodmetric. Moodmetric - apps on google play. Android Apps on Google Play. URL: https://play.google.com/store/apps/details?id=com.moodmetric&amp;hl=en&amp;gl=US (дата звернення: 26.03.2024).
4. GitHub - NureKarasovMykhailo/apzkr-pzpi-21-10-karasov-mykhailo. GitHub. URL: https://github.com/NureKarasovMykhailo/apzkr-pzpi-21-10-karasov-mykhailo (дата звернення: 06.06.2024).
5. Михайло Карасьов. Apzkr-pzpi-21-10-karasov-mykhailo, 2024. YouTube. URL: https://www.youtube.com/watch?v=8p2BIpmdsZY (дата звернення: 06.06.2024).
6. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
7. Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 с.
 
ДОДАТОК А
Специфікація REST


Таблиця А.1 – REST - специфікація
Контролер	Метод	URL	Опис
«Активності»	POST	/activity/	Створює нову активність
	GET	/activity/	Отримання усіх активностей
	GET	/activity/{id}	Отримання активності по id
	PUT	/activity/{id}	Оновлення активності
	POST	/activity/add-employee/{id}	Закріплення робітника за аквтиностею
	POST	/activity/delete-employee/{id}	Видалення робітника з активності
«Авторизація»	POST	/auth/registration	Реєстрація користувача
	POST	/auth/login	Авторизація
	GET	/auth/check-auth	Перевірка авторизації
«Підприємство»	POST	/company/	Створення нового підприємства


Продовження таблиці А.1
Контролер	Метод	URL	Опис
	GET	/company/	Отримання підприємства по JWT токену
	PATCH	/company/	Оновлення підприємства по JWT токену
	POST	/company/add-employee/{id}	Додавання робітника до підприємства
	DELETE	/company/delete-employee/{id}	Видалення робітника з підприємства
	GET	/company/employees	Отримання усіх користувачів підприємства
	GET	/company/employees/{id}	Отримання робітника підприємства по ID
«Складність»	POST	/complexity/	Створення нової складності
	GET	/complexity/	Отримання усіх складностей
	GET	/complexity/{id}	Отримати складність по id



Продовження таблиці А.1
Контролер	Метод	URL	Опис
	PUT	/complexity/{id}	Оновити складність по {id}
	DELETE	/complexity/{id}	Видалити складність по id
«База даних»	GET	/db/	Отримання резервної копії бази даних
«Освіти»	POST	/education/	Створення нової освіти
	GET	/education/	Отримання усіх освіт
	GET	/education/{id}	Отримання освіти по id
	PUT	/education/{id}	Оновити освіту по id
	DELETE	/education/{id}	Видалити освіту по id
«Користувач»	POST	/public-user/patch/	Оновлення даних користувача по JWT токену
	PUT	/public-user/add-education/	Додавання освіти користувачу 



Продовження таблиці А.1
Контролер	Метод	URL	Опис
	PUT	/public-user/delete-education	Видалення освіти у користувача
	POST	/public-user/subscribe	Відправити до API запит на оформлення підписки
«Ролі»	POST	/role/	Додати роль
	GET	/role/	Отримати усі ролі
	GET	/role/{id}	Отримати роль по id
	PUT	/role/{id}	Оновити роль по id
	DELETE	/role/{id}	Видалити роль по id
«Історія сканеру»	POST	/scanner-history	Створення історії сканеру
	GET	/scanner-history/scanner/{id}	Отримати історію сканування для певного сканеру
	GET	/scanner-history/{id}	Отримати історію сканеру по id



Продовження таблиці А.1
Контролер	Метод	URL	Опис
	DELETE	/scanner-history/scanner/{id}	Очистити історію певного сканеру
	DELETE	/scanner-history/{id}	Видалення історії сканеру по id
«Сканер»	POST	/scanner/	Створення нового сканеру
	GET	/scanner/	Отримання усіх сканерів
	GET	/scanner/{id}	Отримання сканеру по id
	PUT	/scanner/{id}	Оновлення сканеру по id
	DELETE	/scanner/{id}	Видалення сканеру по id
«Робочий розклад»	GET	/time-table/{id}	Отримання найбільш підходящого робітника для виконання активності
	GET	/time-table/	Формування оптимального розподілу робітників по активностям
 

ДОДАТОК Б
Оформлення підписки за допомогою API


1. export default class SubscriptionClass {
2. 
3.     private RETURN_URL:string = 
4. 	'http://localhost:5000/api/public-user/subscribe/succeed';
5.     private CANCEL_URL:string = 
6. 	'http://localhost:5000/api/subscription/pay-pal-cancel-  7.payment';
8.     private AUTH: string = 
9. 	Buffer.from(process.env.CLIENT_ID + 
10. 	':' + 
11. 	process.env.PAY_PAL_SECRET_KEY).toString('base64');
12.     private SUBSCRIPTION_PAY_LOAD = {
13.         "plan_id": process.env.PLAN_ID,
14.         "application_context": {
15.             "brand_name": "TaskSync Subscription",
16.             "locale": "en-US",
17.             "user_action": "SUBSCRIBE_NOW",
18.             "payment_method": {
19.                 "payer_selected": "PAYPAL",
20.                 "payee_preferred": 21."IMMEDIATE_PAYMENT_REQUIRED"
22.             },
23.             "return_url": this.RETURN_URL,
24.             "cancel_url": this.CANCEL_URL
25.         }
26.     }
27. 
28.     constructor() {
29. 
30.     }
31. 
32.     async subscribeRequest() {
33. 
34.         return await 
35. 	    fetch('https://api-36.m.sandbox.paypal.com/v1/billing/subscriptions', {
37.             method: 'post',
38.             body: 36.JSON.stringify(this.SUBSCRIPTION_PAY_LOAD),
39.             headers: {
40.                 'Authorization': 'Basic ' + this.AUTH,
41.                 'Content-Type': 'application/json'
42.             },
43.         });
44.     }
45. 
46.     async isSubscriptionValid(subscribe: Subscribe) {
47.         const response = await fetch(
48. 		`https://api-m.sandbox.paypal.com/v1/ ` + `
49. 		billing/subscriptions/${subscribe.code}`, {
50.             method: 'get',
51.             headers: {
52.                 'Authorization': 'Basic ' + this.AUTH,
53.                 'Content-Type': 'application/json'
54.             }
55.         });
56.         const subscriptionDetails = await response.json();
57.         console.log(subscriptionDetails.status)
58.         return subscriptionDetails.status === 'ACTIVE' 
59. 		|| subscriptionDetails.status === 'APPROVAL_PENDING'
60. 		 || subscriptionDetails.status === 'EXPIRED';
61.     }
62. }
 
ДОДАТОК В
Знаходження найкращого робітника для виконання активності


1. export default class TimeTableManager {
2. 
3.     private _activities: ActivityDomainModel[];
4.     private _scannerHistory: ScannerHistoryDomainModel;
5.     private _coefficientsArray!: CoefficientsData[];
6. 
7.     constructor(
8.        activities: ActivityDomainModel[],
9.        scannerHistory: ScannerHistoryDomainModel
10.     ) {
11.         this._activities = activities;
12.         this._scannerHistory = scannerHistory;
13.         this._coefficientsArray = 14.this.getCoefficientsArray();
15.     }
16. 
17.     public getOptimalActivity(): number {
18.         const maxCoefficientData = 19.this.getCoefficientsWithMaxData(this._coefficientsArray);
20. 
21. 
22.         for (let i = 0; i < this._coefficientsArray.length; 23.i++) {
24.             this._coefficientsArray[i].totalCoefficient =
25.                 26.this._coefficientsArray[i].complexityCoefficient / 27.maxCoefficientData.complexityCoefficient +
28.                 this._coefficientsArray[i].pulseCoefficient  29./ maxCoefficientData.pulseCoefficient +
30.                 31.this._coefficientsArray[i].temperatureCoefficient / 32.maxCoefficientData.temperatureCoefficient +
33.                 34.this._coefficientsArray[i].complexityCoefficient / 35.maxCoefficientData.complexityCoefficient;
36.         }
37. 
38.         this._coefficientsArray = 39.this._coefficientsArray.sort((a, b) => b.totalCoefficient – 40.a.totalCoefficient);
41. 
42.         return this._coefficientsArray[0].activityId;
43. 
44.     }
45. 
46.     private getCoefficientsArray() {
47.         let coefficientsArray: CoefficientsData[] = [];
48. 
49.         for (let i = 0; i < this._activities.length; i++) {
50. 
51.             let coefficientsData = new CoefficientsData(
52.                 this._activities[i].id,
53.                 54.this.getTemperatureCoefficient(this._scannerHistory.temperature),
55.                 56.this.getPulseCoefficients(this._scannerHistory.pulse),
57.                 58.this.getActiveWorkCoefficients(this._scannerHistory.activeWo 59.rkedTime),
60.                 this._activities[i].complexity?.evaluation 45.|| 61
62.             );
63.             coefficientsArray.push(coefficientsData);
64.         }
65. 
66.         return coefficientsArray;
67.     }
68. 
69.     private getTemperatureCoefficient(temperature: number): 70.number {
71.         switch (true) {
72.             case (temperature <= 36.6):
73.                 return 1;
74.             case (temperature > 36.6 && temperature <= 37):
75.                 return 1.2;
76.             case (temperature > 37 && temperature <= 37.5):
77.                 return 1.5;
78.             case (temperature > 37.5 && temperature <= 38):
79.                 return 2;
80.             case (temperature > 38 && temperature <= 38.5):
81.                 return 3;
82.             case (temperature > 38.5 && temperature <= 39):
83.                 return 4;
84.             default:
85.                 return 5;
86.         }
87.     }
88. 
89.     private getPulseCoefficients(pulse: number): number {
90.         switch (true) {
91.             case (pulse <= 60):
92.                 return 1;
93.             case (pulse > 60 && pulse <= 80):
94.                 return 1.2;
95.             case (pulse > 80 && pulse <= 100):
96.                 return 1.5;
97.             case (pulse > 100 && pulse <= 120):
98.                 return 2;
99.             case (pulse > 120 && pulse <= 140):
100.                 return 3;
101.             case (pulse > 140 && pulse <= 160):
102.                 return 4;
103.             default:
104.                 return 5;
105.         }
106.     }
107. 
108.     private 109.getActiveWorkCoefficients(activeWorkTimeInSeconds: number): 110.number {
111.         const activeWorkTimeInHours = 112.activeWorkTimeInSeconds;
113.         switch (true) {
114.             case (activeWorkTimeInHours <= 7200):
115.                 return 1;
116.             case (activeWorkTimeInHours > 7200 && 117.activeWorkTimeInHours <= 14400):
118.                 return 1.2;
119.             case (activeWorkTimeInHours > 14400 && 120.activeWorkTimeInHours <= 21600):
121.                 return 1.5;
122.             case (activeWorkTimeInHours > 21600 && 123.activeWorkTimeInHours <= 28800):
124.                 return 2;
125.             case (activeWorkTimeInHours > 28800 && 126.activeWorkTimeInHours <= 36000):
127.                 return 3;
128.             case (activeWorkTimeInHours > 36000 && 129.activeWorkTimeInHours <= 43200):
130.                 return 4;
131.             default:
132.                 return 5;
133.         }
134.     }
135. 
136. 
137.     private getCoefficientsWithMaxData(coefficientsArray: 138.CoefficientsData[]) {
139.         let maxPulseCoefficient = Number.MIN_SAFE_INTEGER;
140.         let maxTemperatureCoefficient = 141.Number.MIN_SAFE_INTEGER;
142.         let maxActiveWorkTimeCoefficient = 143.Number.MIN_SAFE_INTEGER;
144.         let maxComplexityCoefficient = 145.Number.MIN_SAFE_INTEGER;
146. 
147.         for (let i = 0; i < coefficientsArray.length; i++) 148.{
149.             if (maxPulseCoefficient < 150.coefficientsArray[i].pulseCoefficient) {
151.                 maxPulseCoefficient = 152.coefficientsArray[i].pulseCoefficient;
153.             }
154.
155.             if (maxTemperatureCoefficient < 156.coefficientsArray[i].temperatureCoefficient) {
157.                 maxTemperatureCoefficient = 158.coefficientsArray[i].temperatureCoefficient;
159.             }
160. 
161.             if (maxActiveWorkTimeCoefficient < 162.coefficientsArray[i].workTimeCoefficient) {
163.                 maxActiveWorkTimeCoefficient = 164.coefficientsArray[i].workTimeCoefficient;
165.             }
166. 
167.             if (maxComplexityCoefficient < 168.coefficientsArray[i].complexityCoefficient) {
169.                 maxComplexityCoefficient = 170.coefficientsArray[i].complexityCoefficient;
171.             }
172.         }
173. 
174.         return new CoefficientsData(
175.             0,
176.             maxTemperatureCoefficient,
177.             maxPulseCoefficient,
178.             maxActiveWorkTimeCoefficient,
179.             maxComplexityCoefficient
180.         );
181. 
182.     }
183. 
184. }
 
ДОДАТОК Г
Програмний код IoT пристрою


1. #include <WiFi.h>
2. #include <HTTPClient.h>
3. #include "DHTesp.h"
4. 
5. #define BUTTON_PIN 12
6. #define DHT_PIN 15
7. #define PULSE_PIN 35
8. 
9. const char* ssid = "Wokwi-GUEST";
10. const char* password = "";
11. 
12. const char* serverUrl = 
13. "http://host.wokwi.internal:5000/api/scanner-history/";
14. 
15. DHTesp dhtSensor;
16. 
17. unsigned long last_button_press = 0;
18. bool isMeasuring = false;
19. bool isButtonPressed = false;
20. float temperature = 0.0;
21. int pulse = 0;
22. unsigned long activeWorkedTime = 0;
23. int scannerId = 34;
24. 
25. void setup() {
26.   Serial.begin(115200);
27.   Serial.println("Esp 32 work start");
28. 
29.   pinMode(BUTTON_PIN, INPUT_PULLUP);
30.   dhtSensor.setup(DHT_PIN, DHTesp::DHT22);
31. 
32.   WiFi.begin(ssid, password);
33.   while (WiFi.status() != WL_CONNECTED) {
34.     delay(100);
35.     Serial.println("Connecting to WiFi...");
36.   }
37.   Serial.println("Connected to WiFi");
38. }
39. 
40. void loop () {
41.   if (digitalRead(BUTTON_PIN) == LOW
42.  && !isMeasuring && !isButtonPressed) {
43.     delay(10); 
44.     startMeasurement();
45.     delay(20);
46.   } else if (digitalRead(BUTTON_PIN) == HIGH
47.  && isMeasuring && !isButtonPressed) {
48.       isButtonPressed = true;
49.       delay(10);
50.   } else if (digitalRead(BUTTON_PIN) == LOW 
51. && isMeasuring && isButtonPressed) {
52.     delay(10); 
53.     stopMeasurement();
54.   }
55. }
56. 
57. void startMeasurement() {
58.   isMeasuring = true;
59.   last_button_press = millis();
60.   Serial.println("Time measurement started");
61. }
62. 
63. void stopMeasurement() {
64.   isMeasuring = false;
65.   activeWorkedTime = (millis() - last_button_press) / 100;
66.   Serial.print("Time: ");
67.   Serial.println(activeWorkedTime);
68.   measureTemp();
69.   measurePulse();
70.   sendDataToServer();
71. }
72. 
73. void measureTemp() {
74.   TempAndHumidity data = dhtSensor.getTempAndHumidity();
75.   temperature = data.temperature;
76.   Serial.print("Temperature: ");
77.   Serial.print(temperature, 1);
78.   Serial.println("°C");
79. }
80. 
81. void measurePulse() {
82.    int pulseValue = analogRead(PULSE_PIN);
83.   float voltage = pulseValue * (5.0 / 4095.0);
84.   int heartRate = (voltage / 3.3) * 675;
85.   pulse = heartRate;
86.   Serial.print("Heart rate: ");
87.   Serial.println(heartRate);
88. }
89. 
90. void sendDataToServer() {
91.   if (WiFi.status() == WL_CONNECTED) {
92.     HTTPClient http;
93. 
94.     http.begin(serverUrl);
95.     http.addHeader("Content-Type", "application/json");
96. 
97.     String jsonPayload = "{";
98.     jsonPayload += "\"temperature\": " + String(temperature) 99.+ ",";
100.     jsonPayload += "\"pulse\": " + String(pulse) + ",";
101.     jsonPayload += "\"activeWorkedTime\": "
102.  + String(activeWorkedTime) + ",";
103.     jsonPayload += "\"scannerId\": " + String(scannerId);
104.     jsonPayload += "}";
105. 
106.     int httpResponseCode = http.POST(jsonPayload);
107. 
108.     if (httpResponseCode > 0) {
109.       String response = http.getString();
110.       Serial.println("HTTP Response code: " + 111.String(httpResponseCode));
112.       Serial.println("Response: " + response);
113.     } else {
114.       Serial.println("Error on sending POST: " + 115.String(httpResponseCode));
116.     }
117. 
118.     http.end();
119.   } else {
120.     Serial.println("WiFi Disconnected");
121.   }
122. }
 
ДОДАТОК Д
Маршрутизація веб-клієнту


1. import React, {useContext} from 'react';
2. import { Route, Routes} from "react-router-dom";
3. import defaultRoutes, {adminRoutes, authRoutes} from 4."../routes";
5. import {observer} from "mobx-react-lite";
6. import {Context} from "../index";
7. import {getRoleTitles} from "../utils/getRoleTitles";
8. import {RoleEnum} from "../utils/enums/RoleEnum";
9. 
10. const AppRouter = observer(() => {
11.     const { userStore } = useContext(Context);
12. 
13.     return (
14.         <Routes>
15.             { defaultRoutes.map(({path, Element} ) => (
16.                 <Route key={path} path={path} 17.element={<Element />} />
18.             ))}
19.             { userStore.isAuth && authRoutes.map(({path, 20.Element}) => (
21.                 <Route key={path} path={path} element={< 22.Element />} />
23.             )) }
24.             { userStore.isAuth &&  25.getRoleTitles(userStore.user.roles).includes(RoleEnum.ADMIN) 26.&& 26adminRoutes.map(({path, Element}) => (
27.                 <Route key={path} path={path} 28.element={<Element />} />
29.             ))}
30.         </Routes>
31. 
32.     );
33. });
34. 
35. export default AppRouter;
 
ДОДАТОК Ж
Перевірка на плагіат


Рисунок Ж.1 – Результат перевірки на плагіат
